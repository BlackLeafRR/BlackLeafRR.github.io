<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2025/04/24/page/"/>
    <url>/2025/04/24/page/</url>
    
    <content type="html"><![CDATA[<h1 id="网页markdown兼容测试"><a href="#网页markdown兼容测试" class="headerlink" title="网页markdown兼容测试"></a>网页markdown兼容测试</h1><p>这是一篇测试文章 </p><p>用于测试typora md对于hexo的兼容性</p><p><img src="/image/test.assets/image-20250424115434468-1745466880008-1.png"></p><hr><p>img2</p><p><img src="/image/test.assets/image-20250424115515842-1745466918619-3.png" alt="image-20250424115515842"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象基础</title>
    <link href="/2025/04/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA面向对象基础"><a href="#JAVA面向对象基础" class="headerlink" title="JAVA面向对象基础"></a>JAVA面向对象基础</h1><hr><h2 id="定义class"><a href="#定义class" class="headerlink" title="定义class"></a>定义class</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;   <span class="hljs-comment">//一个字段field</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个属性被称为一个字段（field）</p><p><code>public</code>  修饰字段 表示该字段可被外部访问</p><p><code>private</code>  修饰字段 表示该字段只能被内部方法访问</p><p>成员变量在被赋值前会被<strong>零初始化</strong></p><p>实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">xiaojun</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>xiaojun.name = <span class="hljs-string">&quot;xiaojun&quot;</span>;<br>xiaojun.age = <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。</p>          </div><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">ming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        ming.setBirth(<span class="hljs-number">2008</span>);<br>        System.out.println(ming.getAge());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> birth;     <span class="hljs-comment">//private成员变量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBirth</span><span class="hljs-params">(<span class="hljs-type">int</span> birth)</span> &#123;  <span class="hljs-comment">//调用public方法来修改private变量</span><br>        <span class="hljs-built_in">this</span>.birth = birth;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> calcAge(<span class="hljs-number">2019</span>); <span class="hljs-comment">// 调用private方法</span><br>    &#125;<br><br>    <span class="hljs-comment">// private方法（供内部函数调用）:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcAge</span><span class="hljs-params">(<span class="hljs-type">int</span> currentYear)</span> &#123;<br>        <span class="hljs-keyword">return</span> currentYear - <span class="hljs-built_in">this</span>.birth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>private成员变量不可外部访问 由内部的方法访问</p></li><li><p>private方法供内部方法调用</p></li><li><p>public方法是对外接口 供外部调用</p></li></ul><h4 id="this变量"><a href="#this变量" class="headerlink" title="this变量"></a>this变量</h4><p><code>this</code>  是在方法内部的一个隐藏变量 始终指向当前实例</p><p>对于不存在<strong>命名冲突</strong>时 可省略this 但当有局部变量<code>val</code>和class的成员变量(字段)<code>val</code>重名时 在当前域下局部变量优先级更高 故要访问成员变量就需要加上<code>this.val</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// 前面的this不可少，少了就变成局部变量name了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>用<code>type...</code>定义 相当于传入该类型的数组 可以传任意个type类型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Group</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] names;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNames</span><span class="hljs-params">(String... names)</span> &#123;<br>        <span class="hljs-built_in">this</span>.names = names;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般 将<code>String...</code>改写成<code>String[]</code>效果相同 但有一些细节差别：</p><ul><li><p>写<code>String[]</code> 则调用方法时 需先生成一个String数组将n个String放进去 然后再传入数组对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">g.setNames(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-string">&quot;Xiao Hong&quot;</span>, <span class="hljs-string">&quot;Xiao Jun&quot;</span>&#125;); <span class="hljs-comment">// 传入1个String[]</span><br></code></pre></td></tr></table></figure></li><li><p>写<code>String[]</code> 则调用方可以传入null</p></li><li><p>而写<code>String...</code> 只会传入空数组而不可能传入null</p></li></ul><h4 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h4><p>关于传参引用类型的细节：</p><ul><li>传基本类型是按值传递 传引用类型则是传引用（指针）</li><li>如果传入数组 则外部改变数组内容后 实例内相应的数组也会发生改动</li><li>如果传入String 则是传入指向字符串常量的指针 后续在外部修改String变量只会使该String变量指向其他字符串常量 但显然不会改变已经传入的字符串内容</li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>定义构造方法（<strong>无返回值类型</strong> 方法名同类名）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化时调用构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">xiaojun</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xiaojun&quot;</span>,<span class="hljs-number">35</span>);<br></code></pre></td></tr></table></figure><h4 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123; &#125;<br></code></pre></td></tr></table></figure><p>只有在未定义任何构造方法时才会自动定义 若有其他定义后还需要默认构造方法 需手动写一遍</p><h4 id="多个构造方法"><a href="#多个构造方法" class="headerlink" title="多个构造方法"></a>多个构造方法</h4><p>根据实际传参类型匹配合适的构造方法</p><h4 id="字段初始化"><a href="#字段初始化" class="headerlink" title="字段初始化"></a>字段初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//字段初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;<br>  age = <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序：先字段初始化age&#x3D;1 后构造方法初始化age&#x3D;2 故最终age&#x3D;2</p><h2 id="重载Overload"><a href="#重载Overload" class="headerlink" title="重载Overload"></a>重载Overload</h2><p>同名方法根据传参要求不同 可以存在多个实现 称为方法重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//version 1</span><br>    System.out.println(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String name)</span> &#123;   <span class="hljs-comment">//version 2</span><br>    System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;   <span class="hljs-comment">//version 3</span><br>    <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hi, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目的是将功能相似的方法使用同一名字 更可读和易用</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;  <span class="hljs-comment">//private权限</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;    <span class="hljs-comment">//protected权限</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;...&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 不要重复name和age字段/方法,</span><br>    <span class="hljs-comment">// 只需要定义新增score字段/方法:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123; … &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123; … &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>class 子类 extends 基类 &#123; &#125;</code>来创建一个继承类</p><p>子类拥有父类所有的字段和方法 子类中只需定义新增的字段和方法</p><p>父类中的字段若是<code>private</code>则只有父类的方法能访问字段 子类的不行</p><p>改成<code>protected</code>权限的字段 其子类也能访问修改</p><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>指向父类 可用<code>super.fieldName</code>访问父类中定义的字段<br>（一般情况下 在子类中访问父类的name字段 super.name 或 this.name 或 name 效果都是<strong>一样</strong>的 编译器会自动定位到父类的name）</p><p>使用<code>super( )</code>调用父类的构造方法</p><h4 id="构造方法调用"><a href="#构造方法调用" class="headerlink" title="构造方法调用"></a>构造方法调用</h4><p>子类在调用构造方法时 会<strong>自动调用父类的默认构造方法(无参数)</strong> 若父类没有默认构造方法 则会报错 需要<strong>手动在子类中用<code>super(args)</code>调用</strong>父类的某个构造方法  </p><h4 id="向上转型-向下转型"><a href="#向上转型-向下转型" class="headerlink" title="向上转型 &amp; 向下转型"></a>向上转型 &amp; 向下转型</h4><h6 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h6><p>可以用一个<strong>父类类型</strong>的变量指向<strong>子类的实例</strong> 此时这个实例<strong>向上转型</strong> 被视为父类类型的实例并正常工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> s; <span class="hljs-comment">// upcasting, ok</span><br></code></pre></td></tr></table></figure><blockquote><p>[!caution]</p><p>此时p只能使用Person类有的字段和方法 而Student类特有的部分被隐藏起来了（<strong>方法隐藏</strong>）</p></blockquote><h6 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h6><p>将一个父类类型的变量强制转换为子类类型 如果这个变量实际是子类的实例（如上述p变量 实际是Student的实例）那么将成功<strong>向下转型</strong> 这个变量恢复了子类特有的字段和方法</p><p>然而 若这个父类类型的变量实际就是父类的实例 非子类的实例 则<strong>无法向下转型</strong>（即不能把父类实例变成子类实例 不能平白无故多出功能）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(); <span class="hljs-comment">// upcasting, ok</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Student) p1; <span class="hljs-comment">// ok</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> (Student) p2; <span class="hljs-comment">// runtime error! ClassCastException!</span><br></code></pre></td></tr></table></figure><h6 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h6><p>用于判断一个变量是不是某种类型的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <span class="hljs-comment">//向上转型 但它实质是Student</span><br>p1 <span class="hljs-keyword">instanceof</span> Student  <span class="hljs-comment">//true</span><br>p1 <span class="hljs-keyword">instanceof</span> Person   <span class="hljs-comment">//true</span><br><br><span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p2 <span class="hljs-keyword">instanceof</span> Person   <span class="hljs-comment">//true</span><br>p2 <span class="hljs-keyword">instanceof</span> Student  <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p> 子类属于其父类的instanceof</p><p>即 <code>子类变量 instanceof 父类</code> 是true的</p><p>向下转型前可以先用instanceof判断能不能转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) obj;<br>    System.out.println(s.toUpperCase());<br>&#125;<br><br><span class="hljs-comment">//java 14后 也可简写成</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s) &#123;<br>    <span class="hljs-comment">// 可以直接使用变量s:</span><br>    System.out.println(s.toUpperCase());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="覆写Override"><a href="#覆写Override" class="headerlink" title="覆写Override"></a>覆写Override</h4><p>在子类中重新定义一个与父类中已有方法的<strong>签名和返回值完全一样</strong>的新的方法 称为覆写</p><div class="note note-info">            <p>方法签名由两部分组成——方法名+参数列表</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// do something 1</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span>  <span class="hljs-comment">//让编译器检查是否正确覆写</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// do something 2  (something different)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@override</code> 编译器会检查以下方法是否覆写了父类中的某方法（非必须） 不是覆写会报错</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><blockquote><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p><p>具体地，多态允许你通过父类引用来操作子类对象。而这通常是通过方法重写（<code>@Override</code>）实现的</p></blockquote><p>对于存在很多同名方法 对某个变量具体调用哪个方法定义取决于变量的<strong>真实类型</strong>和<strong>传参</strong></p><p>通过<strong>覆写</strong>（根据类型）和<strong>重载</strong>（根据传参） 我们就可以根据实例的<strong>具体类型</strong>和<strong>传参情况</strong>来匹配到我们所应该调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Income</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Income</span><span class="hljs-params">(<span class="hljs-type">double</span> val)</span>&#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span>&#123;     <span class="hljs-comment">//type 1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.val*<span class="hljs-number">0.1</span>;<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StuIncome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Income</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StuIncome</span><span class="hljs-params">(<span class="hljs-type">double</span> val)</span>&#123;<br>        <span class="hljs-built_in">super</span>(val);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span>&#123;     <span class="hljs-comment">//type 2</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.val*<span class="hljs-number">0.05</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialIncome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Income</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SpecialIncome</span><span class="hljs-params">(<span class="hljs-type">double</span> val)</span>&#123;<br>        <span class="hljs-built_in">super</span>(val);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span>&#123;     <span class="hljs-comment">//type 3</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.val*<span class="hljs-number">0.01</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Income</span> <span class="hljs-variable">xiaoli</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Income</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">Income</span> <span class="hljs-variable">lihua</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StuIncome</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">Income</span> <span class="hljs-variable">zhangsan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpecialIncome</span>(<span class="hljs-number">100</span>);<br><br>printTax(xiaoli,lihua,zhangsan);  <span class="hljs-comment">//假如有这么个函数printTax(Income...)</span><br><span class="hljs-comment">//这个函数干了如下的事：</span><br><span class="hljs-comment">//xiaoli.getTax();     //10.0</span><br><span class="hljs-comment">//lihua.getTax(); //5.0</span><br><span class="hljs-comment">//zhangsan.getTax(); //1.0</span><br></code></pre></td></tr></table></figure><p>可见<code>xiaoli</code> <code>lihua</code> <code>zhangsan</code>都是<code>Income</code>引用类型 而其实际类型分别不同 </p><p>但是<code>printTax</code>函数不需要关心实际类型 对于<code>Income</code>的任何子类实例都可以统一对其调用<code>.getTax()</code> 然后都会正确调用其应该调用的方法</p><div class="note note-info">            <p>对于子类的实例 如果其引用类型为父类 则子类扩展部分的方法会被隐藏 无法调用<br>然而调用@Override方法则会正确使用对应子类的方法定义<br>printTax函数是基于父类Income的函数 而通过多态 它能够轻松适用于所有Income的子类实例<br>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p>          </div><h4 id="super调用"><a href="#super调用" class="headerlink" title="super调用"></a>super调用</h4><p>用<code>super.method()</code>可以调用被覆写的父类方法</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul><li><p>被<code>final</code>修饰的方法不可被子类覆写</p><p><code>public final void methodA()&#123;&#125;</code></p></li><li><p>被<code>final</code>修饰的类不能被继承</p><p><code>final class Person &#123;&#125;</code></p></li><li><p>被<code>final</code>修饰的字段在初始化后就不能再被修改了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Unamed&quot;</span>;  <span class="hljs-comment">//直接字段初始化</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<span class="hljs-comment">//或者定义变量时不初始化 在构造方法中初始化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>被<code>final</code>修饰的局部变量不能被重新赋值 （类似常量）</p></li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>@override的父类方法必须也有实现 然而若父类的方法<strong>本身不需要实现任何功能</strong> 目的提供一个方法签名就是让子类去覆写它实现具体功能 可以将父类方法定义为<strong>抽象方法</strong> 而包含抽象方法的类无法实例化 所以需要将其声明为<strong>抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>abstract</code>用于修饰抽象类和抽象方法</p><p><strong>抽象类不能实例化</strong> 只能<strong>用于被继承</strong> 同时这会强迫其子类去实现其抽象方法</p><blockquote><p>[!tip] </p><p>抽象方法实际上相当于定义了“必须实现的接口规范”</p><p>抽象类相当于其子类的一个”模板“</p></blockquote><h4 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h4><p>通过抽象类的引用类型去引用具体的子类的实例 这样只管调用定义好的抽象方法即可 不用关心方法调用时具体的子类类型 以及具体的方法时如何实现的 故只需要基于抽象类来编程就行</p><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><ul><li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>如果一个抽象类中没有字段 只有抽象方法 则可以改写成接口<code>Interface</code> interface比抽象类的抽象程度更高</p><p>interface中只能定义<strong>抽象方法</strong>和<strong>default方法</strong>  所有方法默认都是 <code>public abstract</code> 的故不需要写abstract修饰符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="implements实现接口"><a href="#implements实现接口" class="headerlink" title="implements实现接口"></a>implements实现接口</h4><p>使用<code>implements</code>让一个类去实现<strong>一个或多个</strong>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; run&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可implement多个接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span>, Hello &#123; <span class="hljs-comment">// 实现了两个interface</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h4><p>使用extends将一个接口继承自另一个接口 相当于扩展接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hello</span> &#123;   <span class="hljs-comment">//Person有三个抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h4><p>如果接口里某种方法有默认实现 不强制要求类去覆写实现该方法 则用default关键字来修饰它</p><blockquote><p>[!tip]</p><p><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p></blockquote><blockquote><p>[!tip]</p><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p></blockquote><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><p>接口是<strong>规范了一组行为</strong>（方法）所有implements了这个接口的类无论如何 都具有这个接口所规范的行为 进而 通过接口的引用 就可以去执行接口中所规范的行为</p><p>我们不在乎这个接口引用的具体的实例究竟是什么具体类、具体有什么属性和方法 我们只知道 这个接口能提供什么功能的支持 通过这个接口 不管背后是什么类 总之它能够执行接口支持的行为</p><!-- <img src="面向对象基础.assets/接口和抽象类-1735444788144-2.png" alt="接口和抽象类" style="zoom: 67%;" /> --><p><img src="/image/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB-1735444788144-2.png"></p><p>而抽象类是为具体类提供模板 它更<strong>侧重对于一个个体</strong>的描绘 而不是对行为的描绘 它的描述包括了字段和抽象方法</p><blockquote><p>抽象类是对一类事物的抽象，通常是个名词；接口是对一组行为的抽象，通常是个形容词（具备xxx能力的）。这样就能理解为什么一个类只能继承一个抽象类但是可以实现多个接口了。</p></blockquote><h2 id="静态字段-静态方法"><a href="#静态字段-静态方法" class="headerlink" title="静态字段&amp;静态方法"></a>静态字段&amp;静态方法</h2><h4 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h4><p>用 <code>static</code> 修饰字段 其对于所有类的实例共享 或者说它不属于任何实例</p><p>访问静态字段 <code>类名.静态字段名</code> （写<code>实例.静态字段名</code>编译器会支持 但不建议）</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>调用静态方法不需要实例化 直接 <code>类名.静态方法名</code> 调用 </p><p>静态方法同样不属于一个实例 故它<strong>不能访问类中的非静态方法和字段</strong>（它们属于具体实例）</p><p>静态方法类似函数</p><blockquote><p>[!tip]</p><p>静态方法经常用于工具类。例如：</p><ul><li>Arrays.sort()</li><li>Math.random()</li></ul><p>静态方法也经常用于辅助方法</p></blockquote><h4 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h4><p>interface不能实例化 但是可以有<code>public static final</code> 的字段 可省略这些修饰符 简写<code>type x = 0;</code></p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>package类似于cpp的namespace 用于解决类的名字冲突问题 一个类总是属于某个包的</p><p>在.java文件开头使用 <code>package 包名</code> 来声明这个class属于哪个包</p><p>用<code>xxxx.yyyy.aaa</code>可以体现包的层次（只是体现层级 没有父子关系 没有继承关系）</p><p>java源文件src目录得层次需和包得层次一致（编译后的class文件的bin目录也是）：</p><!-- <img src="面向对象基础.assets/image-20241230204318023-1735562600066-1-1735562608473-3.png" alt="image-20241230204318023" style="zoom:67%;" /> --><p><img src="/image/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/image-20241230204318023-1735562600066-1-1735562608473-3.png"></p><h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h4><ul><li><p>不导入 要调用直接写完整类名 eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mypackage.myarrays.<span class="hljs-type">Array</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">mypackage</span>.myarrays.Array();<br></code></pre></td></tr></table></figure></li><li><p>导入完整类名 要调用使用简单类名 （此时只导入了这一个类）eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> mypackage.myarrays.Array;   <span class="hljs-comment">//导入完整类名</span><br><br><span class="hljs-type">Array</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();    <span class="hljs-comment">//使用Array简单类名</span><br></code></pre></td></tr></table></figure></li><li><p>导入包中所有类（不包括子包中的类）（<strong>不推荐</strong> 因为很难看出Array属于哪个包）eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> mypackage.myarrays.*;   <span class="hljs-comment">//导入mypackage.myarrays中的所有类</span><br><br><span class="hljs-type">Array</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();    <span class="hljs-comment">//使用Array简单类名</span><br></code></pre></td></tr></table></figure></li><li><p>*【不常用】*导入一个类的静态字段和静态方法 eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 导入System类的所有静态字段和静态方法:</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*;<br></code></pre></td></tr></table></figure></li></ul><h4 id="当编译器碰到一个类"><a href="#当编译器碰到一个类" class="headerlink" title="当编译器碰到一个类"></a>当编译器碰到一个类</h4><p>Java编译器最终编译出的<code>.class</code>文件只使用<strong>完整类名</strong>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是完整类名，就直接根据<strong>完整类名</strong>查找这个<code>class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找**当前<code>package</code>**是否存在这个<code>class</code>；</li><li>查找**<code>import</code>的包**是否包含这个<code>class</code>；</li><li>查找**<code>java.lang</code>包**是否包含这个<code>class</code>。</li></ul></li></ul><p>如果按照上面的规则还无法确定类名，则编译报错。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<br><br><span class="hljs-keyword">import</span> java.text.Format;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        java.util.List list; <span class="hljs-comment">// ok，使用完整类名 -&gt; java.util.List</span><br>        <span class="hljs-type">Format</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// ok，使用import的类 -&gt; java.text.Format</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hi&quot;</span>; <span class="hljs-comment">// ok，使用java.lang包的String -&gt; java.lang.String</span><br>        System.out.println(s); <span class="hljs-comment">// ok，使用java.lang包的System -&gt; java.lang.System</span><br>        <span class="hljs-type">MessageFormat</span> <span class="hljs-variable">mf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!tip]</p><p>遍写class的时候 编译器做了：<br>1.自动<code>import</code>当前package中的其他class<br>2.自动<code>import java.lang.*</code></p></blockquote><blockquote><p>[!warning]</p><p>自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入</p></blockquote><h2 id="作用域-访问权限修饰符"><a href="#作用域-访问权限修饰符" class="headerlink" title="作用域 (访问权限修饰符)"></a>作用域 (访问权限修饰符)</h2><h4 id="class的访问权限修饰符"><a href="#class的访问权限修饰符" class="headerlink" title="class的访问权限修饰符"></a>class的访问权限修饰符</h4><ul><li>public</li><li>默认（同个包可访问）</li></ul><h4 id="field-method的访问权限修饰符"><a href="#field-method的访问权限修饰符" class="headerlink" title="field method的访问权限修饰符"></a>field method的访问权限修饰符</h4><ul><li>public</li><li>private</li><li>protected</li><li>默认</li></ul><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><ul><li>public的<code>class</code> <code>interface</code>能被其他任意类访问 包括其他包中的类</li><li>public的 <code>field</code> <code>method</code> 能被其他任意类访问 <em><strong>前提是有访问该类的权限</strong> (先能访问那个类 才能创建那个类的实例 才能谈论可否访问字段或方法)</em></li></ul><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><ul><li>private的 <code>field</code> <code>method</code> 无法被其他类访问 其访问权限被限制在<strong>类的内部</strong></li></ul><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><ul><li>protected的 <code>field</code> <code>method</code> 能被该类的<strong>子类以及子类的子类访问</strong></li><li>以及<strong>同个包</strong>中的其他所有类</li></ul><h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><ul><li>没有以上修饰符的<code>class</code> <code>field</code> <code>method</code>就是package作用域</li><li>只要在同个package 就用权限访问package作用域的类或字段或方法</li></ul><!-- <img src="面向对象基础.assets/image-20250216225806768-1739717900762-1.png" alt="image-20250216225806768" style="zoom:80%;" /> --><p><img src="/image/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/image-20250216225806768-1739717900762-1.png"></p><blockquote><p>[!tip]</p><h3 id="“拥有权限”的拥有者是谁？"><a href="#“拥有权限”的拥有者是谁？" class="headerlink" title="“拥有权限”的拥有者是谁？"></a><strong>“拥有权限”的拥有者是谁？</strong></h3><p>“拥有权限”的拥有者是指<strong>试图访问某个类或类成员的代码所在的类</strong>。也就是说：</p><ul><li>如果你在类 <code>A</code> 中写了一段代码，试图访问类 <code>B</code> 的字段或方法，那么“拥有权限”的拥有者就是类 <code>A</code>。</li><li>类 <code>A</code> 是否有权限访问类 <code>B</code> 或其成员，取决于：<ol><li>类 <code>B</code> 的访问修饰符。</li><li>类 <code>A</code> 和类 <code>B</code> 是否在同一个包中。</li><li>类 <code>A</code> 是否是类 <code>B</code> 的子类（如果是 <code>protected</code> 成员）。</li></ol></li></ul></blockquote><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>方法内部定义的变量 就是局部变量作用域 效果与c++局部变量一致</p><blockquote><p>[!tip]</p><p>不需要public就尽量不要声明为public 应减少对外暴露的方法和字段</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Set的用法</title>
    <link href="/2025/04/24/set%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2025/04/24/set%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul><li><p>insert(x) 将x加入set中</p></li><li><p>find(x) 返回x的迭代器 不存在则返回end()</p></li><li><p>erase(it&#x2F;x) 删除元素（可传入迭代器或者值）</p></li><li><p>count(x) 返回x值的个数 （只能是0或1）</p></li><li><p>size() 返回set中元素个数</p></li><li><p>empty() 是否为空</p></li><li><p>begin() &#x2F; end() 返回迭代器</p></li><li><p>clear() 清空</p></li><li><p>lower_bound(x) 返回第一个大于等于x的元素的迭代器</p><p><em>PS. map的 lower_bound 比较依据是 key</em></p></li><li><p>upper_bound(x)  返回第一个大于x元素的迭代器</p></li><li><p>结构体set 需要对结构体重载&lt;运算符（因为set是有序的 需要比较大小的规则）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;u)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> x==u.x ? y&lt;u.y : x&lt;u.x;<br>        <span class="hljs-comment">//实现先比较x大小再比较y大小的排序规则</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算竟</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java语法基础</title>
    <link href="/2025/04/23/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/23/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul><li>整数 byte short int long</li><li>浮点 float double</li><li>字符 char ( 2 byte Unicode存储 )</li><li>布尔 boolean</li><li><strong>引用类型</strong>（除了上述基本类型 剩下的都是引用）e.g. String类型</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>加<code>final</code>修饰符是变量变成常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>通常变量名大写</p><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>自动推断类型 （相当于auto）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">var</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br></code></pre></td></tr></table></figure><h2 id="运算的细节"><a href="#运算的细节" class="headerlink" title="运算的细节"></a>运算的细节</h2><ul><li>整数除法除数为0时 编译能过 运行报错<br>浮点数除法时 除数为0 被除数非零 返回特殊值 Infinity</li><li>浮点数强制转为整数 小数部分被丢弃 若整数爆了 返回整数最大值</li></ul><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>char用Unicode存储 2byte</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;中&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\u0041&#x27;</span>; <span class="hljs-comment">//unicode编码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;  <span class="hljs-comment">//得到Unicode编码 十进制65 十六进制\u0041</span><br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>String为引用类型 一个字符串可存任意长度个字符</p><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><ul><li><code>\&quot;</code> 表示字符<code>&quot;</code></li><li><code>\&#39;</code> 表示字符<code>&#39;</code></li><li><code>\\</code> 表示字符<code>\</code></li><li><code>\n</code> 表示换行符</li><li><code>\r</code> 表示回车符</li><li><code>\t</code> 表示Tab</li><li><code>\u####</code> 表示一个Unicode编码的字符</li></ul><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><p>加号连接 非字符串元素会先<strong>自动转换</strong>为字符串（但至少得先有一个string元素 可以是空串“”） 再拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, No.&quot;</span> + num;<br></code></pre></td></tr></table></figure><h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p><code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（Text Blocks）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">           SELECT * FROM</span><br><span class="hljs-string">             users</span><br><span class="hljs-string">           WHERE id &gt; 100</span><br><span class="hljs-string">           ORDER BY name DESC</span><br><span class="hljs-string">       &quot;&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><p>上述多行字符串实际上是5行，在最后一个<code>DESC</code>后面还有一个<code>\n</code>。如果我们不想在字符串末尾加一个<code>\n</code>，就需要这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">           SELECT * FROM</span><br><span class="hljs-string">             users</span><br><span class="hljs-string">           WHERE id &gt; 100</span><br><span class="hljs-string">           ORDER BY name DESC&quot;&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><p>还需要注意到，多行字符串前面<strong>共同的空格</strong>会被去掉，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">...........SELECT * FROM</span><br><span class="hljs-string">...........  users</span><br><span class="hljs-string">...........WHERE id &gt; 100</span><br><span class="hljs-string">...........ORDER BY name DESC</span><br><span class="hljs-string">...........&quot;&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><p>用<code>.</code>标注的空格都会被去掉。</p><p>如果多行字符串的排版不规则，那么，去掉的空格就会变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">.........  SELECT * FROM</span><br><span class="hljs-string">.........    users</span><br><span class="hljs-string">.........WHERE id &gt; 100</span><br><span class="hljs-string">.........  ORDER BY name DESC</span><br><span class="hljs-string">.........  &quot;&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><p>即总是<strong>以最短的行首空格为基准</strong>。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] s0;<br><span class="hljs-type">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span>[] ss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span>[] sss = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;; <span class="hljs-comment">//只有声明时 可以这么简写</span><br></code></pre></td></tr></table></figure><p>数组类型形式为 type[] 其为引用类型 故理解为指向一个数组 </p><p>使用new type[size]来创建一个size大小的数组 同时各项默认初始化为0</p><p>使用{1,2,3}指定各项初始值 此时new type[]括号需留空 自动推算长度</p><p>也可简写 不写new 直接花括号初始化（仅限声明时）</p><p>数组是引用类型 可以改变引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] s;<br>s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;    <span class="hljs-comment">//s从数组&#123;1,2,3&#125;变成了数组&#123;4,5&#125;</span><br></code></pre></td></tr></table></figure><h4 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h4><p>直接print数组变量 输出的是引用地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] ns = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span> &#125;;<br>System.out.println(ns); <span class="hljs-comment">// 类似 [I@7852e922</span><br></code></pre></td></tr></table></figure><p><code>java.util.Arrays</code>库提供了<code>Arrays.toString(str)</code>可以快捷打印数组内容 （输出类似python）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] ns = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span> &#125;;<br>System.out.println(Arrays.toString(ns));<br></code></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p><code>java.util.Arrays</code>库提供排序函数<code>Arrays.sort()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] s = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>&#125;;<br>Arrays.sort(s);<br>System.out.println(Arrays.toString(s));<br></code></pre></td></tr></table></figure><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>定义如下，<code>Arrays.deepToString()</code>可以快捷打印多维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] ns = &#123;<br>    &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;,<br>    &#123; <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;,<br>    &#123; <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;<br>&#125;;<br>System.out.println(Arrays.deepToString(ns));<br></code></pre></td></tr></table></figure><p>二维数组每个子数组的长度并不要求相同</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>输出 System.out.print();</li><li>整行输出 System.out.println();   （自动换行）</li><li>格式化输出输出 System.out.printf();  （跟C语言一样）</li></ul><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li><p>导入<code>import java,util.Scanner;</code>库</p></li><li><p>新建Scanner对象 <code>Scanner sc = new Scanner(System.in);</code></p></li><li><p>读取一行<code>String s = sc.nextLine();</code><br>读取整数<code>String s = sc.nextInt();</code></p></li></ul><h2 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h2><ul><li><p>判断值是否相等 <code>==</code> 对于引用类型 就是判断是否引用的同个对象</p></li><li><p>判断两个引用类型变量内容是否相等<code>.equal()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;h&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;h&quot;</span>;<br><span class="hljs-keyword">if</span>(s1.equal(s2))&#123;<br>    System.out.println(<span class="hljs-string">&quot;True&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>PS . 若s1为null 则会报<code>NullPointerException</code></p></li></ul><h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><h4 id="传统switch语句"><a href="#传统switch语句" class="headerlink" title="传统switch语句"></a>传统switch语句</h4><p>跟C语言一致（但支持更多类型 包括String）</p><h4 id="switch表达式"><a href="#switch表达式" class="headerlink" title="switch表达式"></a>switch表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span>(fruit)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Apple&quot;</span> -&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span> -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;WOW&quot;</span>);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">//返回值</span><br>    &#125;<br>    <span class="hljs-keyword">default</span> -&gt; &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> b+c;<br>        <span class="hljs-keyword">yield</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新版switch表达式<strong>不用break</strong> 保证只会执行一条分支 且保证必然执行一条分支 故<strong>case必须包含所有可能</strong>（可以用default）</p><p>switch表达式本身有返回值 可以直接赋值给变量 yield语句相当于return 用于设置返回值 （当-&gt;后只有一个值 可省略yield）</p><h2 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h2><p>相当于c++ range-based for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] s = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : s)&#123;<br>    System.out.println(n);<br>&#125;<br></code></pre></td></tr></table></figure><p>其能够遍历所有可迭代数据类型（e.g. List , Map …）</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>main函数接收一个String[]参数 即为命令行传入的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> s:args)&#123;<br>        <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;--test&quot;</span>))&#123;<br>            System.out.println(<span class="hljs-string">&quot;test success!&quot;</span>);<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以读取args这个String数组来处理命令行参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt; java hello --test<br>test success!<br>Hello World!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/04/23/hello-world/"/>
    <url>/2025/04/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
